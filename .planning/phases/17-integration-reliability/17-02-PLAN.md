---
phase: 17-integration-reliability
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - src/infra/temp-file-manager.ts
  - src/infra/temp-file-manager.test.ts
  - src/agents/sdk-runner/sdk-runner.ts
  - src/agents/cli-runner.ts
autonomous: true
requirements: [INTEG-01, INTEG-04, INTEG-05]

must_haves:
  truths:
    - "Prompts >10KB write to temp file instead of inline args (no ARG_MAX errors)"
    - "Temp files cleanup in finally block even if operation fails"
    - "Agent SDK calls enforce 120s timeout using AbortController"
    - "SDK errors include retry logic (transient failures retry 3 times)"
    - "Codex subprocess calls have proper error handling and timeout enforcement"
  artifacts:
    - path: "src/infra/temp-file-manager.ts"
      provides: "Temp file creation, cleanup, ARG_MAX mitigation"
      min_lines: 80
      exports: ["withTempFile", "ARG_MAX_THRESHOLD"]
    - path: "src/infra/temp-file-manager.test.ts"
      provides: "Temp file manager validation tests"
      min_lines: 60
    - path: "src/agents/sdk-runner/sdk-runner.ts"
      provides: "SDK runner with timeout + retry + ARG_MAX mitigation"
      contains: "callWithTimeout.*SDK_TIMEOUT_MS"
  key_links:
    - from: "src/agents/sdk-runner/sdk-runner.ts"
      to: "src/infra/temp-file-manager.ts"
      via: "import and withTempFile wrapper"
      pattern: "withTempFile.*prompt"
    - from: "src/agents/sdk-runner/sdk-runner.ts"
      to: "src/agents/retry-logic.ts"
      via: "retryWithBackoff wrapper"
      pattern: "retryWithBackoff.*sdk"
    - from: "src/agents/cli-runner.ts"
      to: "src/agents/timeout-enforcement.ts"
      via: "callWithTimeout wrapper"
      pattern: "callWithTimeout.*codex"
---

<objective>
Eliminate ARG_MAX errors, SDK timeouts, and subprocess failures by implementing temp file fallback for large prompts, timeout enforcement for SDK calls, and retry logic for all subprocess operations.

Purpose: Fix the three most common integration failure modes: (1) silent ARG_MAX errors when prompts exceed 260KB, (2) SDK calls hanging without timeout, (3) Codex subprocess calls failing without retry.

Output: Temp file manager module, updated SDK runner with timeout/retry/ARG_MAX mitigation, and hardened CLI runner with proper error handling.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/17-integration-reliability/17-CONTEXT.md
@.planning/phases/17-integration-reliability/17-RESEARCH.md
@.planning/phases/17-integration-reliability/17-01-PLAN.md
@src/agents/sdk-runner/sdk-runner.ts
@src/agents/cli-runner.ts
@src/agents/retry-logic.ts
@src/agents/timeout-enforcement.ts
</context>

<interfaces>
<!-- Types from Plan 17-01 that this plan uses -->

From src/agents/retry-logic.ts (created in 17-01):

```typescript
export function retryWithBackoff<T>(
  operation: () => Promise<T>,
  context: { name: string; circuitKey?: string },
): Promise<T>;

export function isRetryableError(error: unknown): boolean;
```

From src/agents/timeout-enforcement.ts (created in 17-01):

```typescript
export function callWithTimeout<T>(
  operation: (signal: AbortSignal) => Promise<T>,
  timeoutMs: number,
  context: string,
): Promise<T>;

export const MCP_TIMEOUT_MS = 30_000;
export const SDK_TIMEOUT_MS = 120_000;
```

From Node.js stdlib:

```typescript
// node:fs/promises
export function writeFile(path: string, content: string, encoding: string): Promise<void>;
export function unlink(path: string): Promise<void>;

// node:os
export function tmpdir(): string;

// node:path
export function join(...paths: string[]): string;
```

</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create temp file manager for ARG_MAX mitigation</name>
  <files>src/infra/temp-file-manager.ts, src/infra/temp-file-manager.test.ts</files>
  <action>
Create `src/infra/temp-file-manager.ts` implementing:

**Core function:**

- `withTempFile<T>(content: string, operation: (filePathOrContent: string) => Promise<T>): Promise<T>` — If content < 10KB, pass content directly to operation. If >= 10KB, write to temp file, pass file path to operation, cleanup in finally block.

**Implementation:**

```typescript
import * as fs from "node:fs/promises";
import * as os from "node:os";
import * as path from "node:path";

export const ARG_MAX_THRESHOLD = 10_000; // 10KB (conservative)

export async function withTempFile<T>(
  content: string,
  operation: (filePathOrContent: string) => Promise<T>,
): Promise<T> {
  if (content.length < ARG_MAX_THRESHOLD) {
    // Small content—pass inline
    return operation(content);
  }

  // Large content—use temp file
  const tmpDir = os.tmpdir();
  const tmpFile = path.join(
    tmpDir,
    `openclaw-prompt-${Date.now()}-${Math.random().toString(36).slice(2)}.txt`,
  );

  try {
    await fs.writeFile(tmpFile, content, "utf-8");
    console.info(`[temp-file] Created ${tmpFile} for ${content.length} byte prompt`);
    return await operation(tmpFile);
  } finally {
    // Always cleanup
    try {
      await fs.unlink(tmpFile);
    } catch (cleanupError) {
      console.warn(`[temp-file] Failed to cleanup ${tmpFile}:`, cleanupError);
    }
  }
}
```

Create `src/infra/temp-file-manager.test.ts` with vitest tests:

- Small content (<10KB) passes inline (no file created)
- Large content (>10KB) creates temp file and passes file path
- Temp file is cleaned up after successful operation
- Temp file is cleaned up after failed operation (cleanup in finally)
- Collision-resistant temp file names (timestamp + random suffix)
- graceful cleanup error handling (logs warning, doesn't throw)
  </action>
  <verify>
  <automated>pnpm test src/infra/temp-file-manager.test.ts --run</automated>
  </verify>
  <done>
- `src/infra/temp-file-manager.ts` exports withTempFile, ARG_MAX_THRESHOLD
- 6+ tests passing validating temp file creation, cleanup, threshold behavior
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 2: Update SDK runner with timeout, retry, and ARG_MAX mitigation</name>
  <files>src/agents/sdk-runner/sdk-runner.ts</files>
  <action>
Update `src/agents/sdk-runner/sdk-runner.ts` to add timeout, retry, and temp file fallback:

**Imports to add:**

```typescript
import { retryWithBackoff } from "../retry-logic.js";
import { callWithTimeout, SDK_TIMEOUT_MS } from "../timeout-enforcement.js";
import { withTempFile, ARG_MAX_THRESHOLD } from "../../infra/temp-file-manager.js";
```

**Find the main SDK query function** (likely `query()` or `runSdkAgent()`) and wrap with three layers:

1. **Outermost: Retry wrapper**

```typescript
return retryWithBackoff(
  async () => {
    // ... timeout + temp file logic ...
  },
  { name: "sdk:query", circuitKey: "agent-sdk" },
);
```

2. **Middle: Timeout wrapper**

```typescript
return callWithTimeout(
  async (signal) => {
    // ... temp file + SDK call logic ...
  },
  SDK_TIMEOUT_MS,
  "sdk:query",
);
```

3. **Inner: Temp file wrapper** (for prompts only)

```typescript
return withTempFile(prompt, async (promptOrPath) => {
  const args =
    promptOrPath.length > ARG_MAX_THRESHOLD
      ? ["--prompt-file", promptOrPath] // Use file path
      : ["--prompt", promptOrPath]; // Use inline content

  // Pass signal to SDK for cancellation support
  const result = await sdkClient.query({ args, signal });
  return result;
});
```

**Key details:**

- Pass AbortSignal from callWithTimeout to SDK client (if supported)
- Handle both inline prompts and file paths based on threshold
- Circuit breaker key: "agent-sdk" (prevents retry storms on SDK failures)
- Log context: "sdk:query" (appears in observability events)

**Don't break existing functionality:**

- Preserve all existing SDK options (model, temperature, etc.)
- Keep existing error handling for non-retryable errors
- Maintain backward compatibility with callers
  </action>
  <verify>
  <automated>pnpm test src/agents/sdk-runner/sdk-runner.test.ts --run && pnpm check</automated>
  </verify>
  <done>
- SDK runner imports retry-logic, timeout-enforcement, temp-file-manager
- SDK calls wrapped in retryWithBackoff → callWithTimeout → withTempFile
- Prompts >10KB use temp file (no ARG_MAX errors)
- SDK calls timeout after 120s
- Transient failures retry up to 3 times
- Existing tests still pass (backward compatible)
  </done>
  </task>

<task type="auto">
  <name>Task 3: Add retry and timeout to Codex subprocess calls</name>
  <files>src/agents/cli-runner.ts</files>
  <action>
Update `src/agents/cli-runner.ts` to add retry and timeout enforcement:

**Imports to add:**

```typescript
import { retryWithBackoff } from "./retry-logic.js";
import { callWithTimeout } from "./timeout-enforcement.js";
```

**Find the main Codex subprocess call** (likely in `runCliAgent()` or similar) and wrap with retry + timeout:

**Retry wrapper:**

```typescript
return retryWithBackoff(
  async () => {
    // ... timeout + subprocess logic ...
  },
  { name: "codex:subprocess", circuitKey: "codex-cli" },
);
```

**Timeout enforcement:**
The existing code likely uses ProcessSupervisor with timeoutMs. Verify it passes timeout to supervisor:

```typescript
const managedRun = await supervisor.spawn({
  // ... existing config ...
  timeoutMs: params.timeoutMs, // Should already exist
  noOutputTimeoutMs, // Should already exist
});
```

If timeout is properly enforced by ProcessSupervisor, no changes needed to timeout logic. If not, wrap in callWithTimeout.

**Error classification enhancement:**
The existing code has FailoverError classification. Verify it classifies:

- Network errors (ECONNRESET, ETIMEDOUT) → retryable
- Auth errors (401, 403) → permanent
- Timeout errors → retryable (with backoff)

If classification is incomplete, update `classifyFailoverReason()` to match isRetryableError logic.

**Don't break existing functionality:**

- Keep ProcessSupervisor integration (already handles process cleanup)
- Preserve existing error messages and FailoverError structure
- Maintain backward compatibility with callers
  </action>
  <verify>
  <automated>pnpm test src/agents/cli-runner.test.ts --run && pnpm check</automated>
  </verify>
  <done>
- CLI runner imports retry-logic
- Codex subprocess calls wrapped in retryWithBackoff
- Timeout enforcement verified (via ProcessSupervisor or callWithTimeout)
- Error classification matches isRetryableError logic
- Existing tests still pass (backward compatible)
- Circuit breaker prevents retry storms on Codex failures
  </done>
  </task>

</tasks>

<verification>
**Behavioral validation:**
- Create a >10KB prompt and verify temp file is created
- Trigger SDK timeout (mock slow response) and verify abort after 120s
- Trigger transient error and verify 3 retries with backoff
- Trigger permanent error and verify immediate failure (no retry)
- Verify temp file cleanup even on operation failure

**Integration validation:**

- SDK runner successfully calls Agent SDK (smoke test)
- CLI runner successfully calls Codex CLI (smoke test)
- Observability events logged for failures, timeouts, retries
- Circuit breaker opens after 5 consecutive failures
  </verification>

<success_criteria>

- [ ] `src/infra/temp-file-manager.ts` created with withTempFile, ARG_MAX_THRESHOLD
- [ ] SDK runner wrapped in retry + timeout + temp file layers
- [ ] CLI runner wrapped in retry layer with proper error classification
- [ ] Prompts >10KB use temp file (no ARG_MAX errors)
- [ ] SDK calls timeout after 120s using AbortController
- [ ] Transient failures retry up to 3 times with exponential backoff
- [ ] Permanent errors fail immediately without retry
- [ ] All existing tests still pass (backward compatible)
- [ ] 6+ new tests for temp file manager
      </success_criteria>

<output>
After completion, create `.planning/phases/17-integration-reliability/17-02-SUMMARY.md`
</output>
