---
phase: 17-integration-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/retry-logic.ts
  - src/agents/retry-logic.test.ts
  - src/agents/timeout-enforcement.ts
  - src/agents/timeout-enforcement.test.ts
autonomous: true
requirements: [INTEG-02, INTEG-04]

must_haves:
  truths:
    - "MCP calls retry on transient failures (ECONNRESET, ETIMEDOUT, 503, 429) with exponential backoff"
    - "Circuit breaker opens after 5 consecutive MCP failures, preventing retry storms"
    - "All integration calls enforce timeouts (30s MCP, 120s SDK) using AbortController"
    - "Timeout errors log to observability.sqlite with integration type and duration"
    - "Permanent errors (400, 401, 404) fail immediately without retry"
  artifacts:
    - path: "src/agents/retry-logic.ts"
      provides: "Retry with exponential backoff, error classification, circuit breaker integration"
      min_lines: 150
      exports: ["retryWithBackoff", "isRetryableError", "logIntegrationFailure"]
    - path: "src/agents/retry-logic.test.ts"
      provides: "Retry logic validation tests"
      min_lines: 100
    - path: "src/agents/timeout-enforcement.ts"
      provides: "Timeout enforcement with AbortController"
      min_lines: 80
      exports: ["callWithTimeout"]
    - path: "src/agents/timeout-enforcement.test.ts"
      provides: "Timeout enforcement tests"
      min_lines: 60
  key_links:
    - from: "src/agents/retry-logic.ts"
      to: "src/infra/circuit-breaker.ts"
      via: "import and execute() wrapper"
      pattern: "CircuitBreaker.*execute"
    - from: "src/agents/retry-logic.ts"
      to: "observability.sqlite"
      via: "better-sqlite3 insert"
      pattern: "INSERT INTO events.*integration.*failure"
    - from: "src/agents/timeout-enforcement.ts"
      to: "AbortController"
      via: "Node stdlib"
      pattern: "new AbortController"
---

<objective>
Create shared retry and timeout infrastructure that all integration points can use to handle transient failures, enforce timeouts, and prevent retry storms.

Purpose: Eliminate flaky MCP calls, SDK timeouts, and cascading failures by providing standardized retry/timeout utilities that work with the existing circuit breaker from Phase 16.

Output: Two reusable modules (retry-logic.ts, timeout-enforcement.ts) with comprehensive test coverage that can be imported by SDK runner, MCP servers, CLI runner, and hooks.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/17-integration-reliability/17-CONTEXT.md
@.planning/phases/17-integration-reliability/17-RESEARCH.md
@.planning/phases/16-service-hardening/16-01-SUMMARY.md
@.planning/phases/16-service-hardening/16-02-SUMMARY.md
@src/infra/circuit-breaker.ts
@src/agents/cli-runner.ts
</context>

<interfaces>
<!-- Existing types from Phase 16 that this plan uses -->

From src/infra/circuit-breaker.ts:

```typescript
export type CircuitState = "closed" | "open" | "half-open";

export class CircuitBreaker {
  constructor(key: string, options?: CircuitBreakerOptions);
  async execute<T>(fn: () => Promise<T>): Promise<T>;
  getState(): CircuitState;
  getFailureCount(): number;
}
```

From src/agents/cli-runner.ts (existing error classification):

```typescript
// FailoverError used for error classification
class FailoverError extends Error {
  reason: "timeout" | "network" | "auth" | "rate-limit" | "unknown";
  provider: string;
  model: string;
  status: number;
}
```

From better-sqlite3 (observability logging):

```typescript
// Observability events schema
// INSERT INTO events (timestamp, category, event_type, metadata)
// category: 'integration', event_type: 'failure'
// metadata: JSON { integration, error, retry_count }
```

</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create retry logic module with exponential backoff</name>
  <files>src/agents/retry-logic.ts, src/agents/retry-logic.test.ts</files>
  <action>
Create `src/agents/retry-logic.ts` implementing:

**Core functions:**

- `isRetryableError(error: unknown): boolean` — Classify errors as retryable (ECONNRESET, ETIMEDOUT, ENOTFOUND, EPIPE, 429, 503, 504) or permanent (400, 401, 403, 404). Respect FailoverError classification (retry on timeout/network, not auth/rate-limit).
- `retryWithBackoff<T>(operation: () => Promise<T>, context: { name: string; circuitKey?: string }): Promise<T>` — Max 3 retries, exponential backoff (1s, 2s, 4s, 8s), check circuit breaker before retry, reset breaker on success, open breaker after exhausted retries.
- `logIntegrationFailure(params: { integration: string; error: string; retryCount: number; timestamp: number })` — Log final failure to observability.sqlite after all retries exhausted (not every attempt). Use better-sqlite3 with busy_timeout 5000ms.

**Error classification constants:**

```typescript
const RETRYABLE_ERRORS: Set<string> = new Set(["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EPIPE"]);
const RETRYABLE_HTTP_CODES: Set<number> = new Set([429, 503, 504]);
const MAX_RETRIES = 3;
const BACKOFF_BASE_MS = 1000;
```

**Circuit breaker integration:**

- If circuitKey provided, check CircuitBreaker state before retry loop
- If open and timeout not elapsed, throw immediately without retries
- If half-open, allow single attempt
- On success, reset breaker (failures=0, state=closed)
- On exhausted retries, increment breaker (if failures >= 5, state=open)

**Observability logging:**

- Only log final failure (after all retries exhausted)
- Include: integration name, error message, retry count, timestamp
- Handle SQLite errors gracefully (log to stderr, don't crash)

Create `src/agents/retry-logic.test.ts` with vitest tests:

- isRetryableError classifies network errors correctly (ECONNRESET, ETIMEDOUT → true)
- isRetryableError classifies permanent errors correctly (400, 401, 404 → false)
- isRetryableError respects FailoverError classification (timeout → true, auth → false)
- retryWithBackoff retries transient failures with exponential backoff (1s, 2s, 4s)
- retryWithBackoff fails immediately on permanent errors (no retry)
- Circuit breaker integration: opens after 5 failures, rejects when open
- Observability logging: writes to events table with correct metadata
  </action>
  <verify>
  <automated>pnpm test src/agents/retry-logic.test.ts --run</automated>
  </verify>
  <done>
- `src/agents/retry-logic.ts` exports retryWithBackoff, isRetryableError, logIntegrationFailure
- 7+ tests passing validating retry behavior, error classification, circuit breaker integration
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create timeout enforcement module with AbortController</name>
  <files>src/agents/timeout-enforcement.ts, src/agents/timeout-enforcement.test.ts</files>
  <action>
Create `src/agents/timeout-enforcement.ts` implementing:

**Core function:**

- `callWithTimeout<T>(operation: (signal: AbortSignal) => Promise<T>, timeoutMs: number, context: string): Promise<T>` — Create AbortController, set timeout to abort after timeoutMs, pass signal to operation, log timeout to observability, cleanup timeout handle in finally block.

**Timeout constants:**

```typescript
export const MCP_TIMEOUT_MS = 30_000; // 30 seconds for MCP calls
export const SDK_TIMEOUT_MS = 120_000; // 120 seconds for SDK calls
```

**Implementation:**

- Create AbortController
- Start timeout: `setTimeout(() => controller.abort(), timeoutMs)`
- Execute operation with signal: `await operation(controller.signal)`
- Catch AbortError: if signal aborted, log to observability and throw timeout error
- Finally: clear timeout handle to prevent leak

**Observability logging:**

- Category: 'integration', event_type: 'timeout'
- Metadata: { integration: context, timeout_ms: timeoutMs }
- Use same logIntegrationFailure pattern (better-sqlite3, graceful error handling)

Create `src/agents/timeout-enforcement.test.ts` with vitest tests:

- callWithTimeout completes successfully when operation finishes before timeout
- callWithTimeout aborts and throws when operation exceeds timeout
- AbortSignal is properly passed to operation function
- Timeout handle is cleared on success (no leak)
- Timeout handle is cleared on operation error (no leak)
- Timeout error logs to observability with correct metadata
  </action>
  <verify>
  <automated>pnpm test src/agents/timeout-enforcement.test.ts --run</automated>
  </verify>
  <done>
- `src/agents/timeout-enforcement.ts` exports callWithTimeout, MCP_TIMEOUT_MS, SDK_TIMEOUT_MS
- 6+ tests passing validating timeout behavior, cleanup, observability logging
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 3: Integration validation and documentation</name>
  <files>src/agents/retry-logic.ts, src/agents/timeout-enforcement.ts</files>
  <action>
Add JSDoc comments to both modules explaining:

**For retry-logic.ts:**

- Purpose: "Retry transient failures with exponential backoff, circuit breaker protection, and observability logging"
- When to use: "All external integration calls (SDK, MCP, subprocess)"
- Example usage:

```typescript
const result = await retryWithBackoff(async () => callMcpTool("kb_query", { query: "AI" }), {
  name: "mcp:kb_query",
  circuitKey: "mcp-kb-server",
});
```

**For timeout-enforcement.ts:**

- Purpose: "Enforce timeouts on async operations using AbortController"
- When to use: "All integration calls that need cancellation (MCP, SDK, subprocess)"
- Example usage:

```typescript
const result = await callWithTimeout(
  async (signal) => fetch(url, { signal }),
  MCP_TIMEOUT_MS,
  "mcp:external-api",
);
```

Run validation tests:

- `pnpm test src/agents/retry-logic.test.ts src/agents/timeout-enforcement.test.ts --run`
- `pnpm check` (TypeScript compilation)

Verify exports are usable by other modules:

- Both modules use ESM exports
- No circular dependencies
- better-sqlite3 imported correctly (dynamic require for native module)
  </action>
  <verify>
  <automated>pnpm test src/agents/retry-logic.test.ts src/agents/timeout-enforcement.test.ts --run && pnpm check</automated>
  </verify>
  <done>
- Both modules have comprehensive JSDoc comments with usage examples
- All tests passing (13+ total tests)
- TypeScript compilation clean
- Modules ready for import by SDK runner, MCP servers, CLI runner, hooks
  </done>
  </task>

</tasks>

<verification>
**Integration validation:**
- Import retry-logic in another file without errors
- Import timeout-enforcement in another file without errors
- Circuit breaker integration works (state transitions verified)
- Observability logging works (events table populated)

**Behavioral validation:**

- Transient errors retry with exponential backoff
- Permanent errors fail immediately
- Timeouts abort operations and log to observability
- Circuit breaker opens after 5 failures
- No resource leaks (timeout handles cleaned up)
  </verification>

<success_criteria>

- [ ] `src/agents/retry-logic.ts` created with retryWithBackoff, isRetryableError, logIntegrationFailure
- [ ] `src/agents/timeout-enforcement.ts` created with callWithTimeout, timeout constants
- [ ] 13+ tests passing validating retry, timeout, circuit breaker integration
- [ ] TypeScript compilation clean
- [ ] JSDoc comments explain usage and examples
- [ ] Observability logging writes to events table with correct schema
- [ ] Circuit breaker integration prevents retry storms
- [ ] All timeout handles cleaned up (no leaks)
      </success_criteria>

<output>
After completion, create `.planning/phases/17-integration-reliability/17-01-SUMMARY.md`
</output>
