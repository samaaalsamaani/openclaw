---
phase: 17-integration-reliability
plan: 03
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - src/plugins/hook-executor.ts
  - src/plugins/hook-executor.test.ts
  - src/agents/sdk-runner/mcp-servers.ts
  - src/agents/sdk-runner/mcp-servers.test.ts
autonomous: true
requirements: [INTEG-02, INTEG-03, INTEG-06]

must_haves:
  truths:
    - "All hooks (PreToolUse, PostToolUse, SessionStart) wrapped in try/catch error boundaries"
    - "Hook failures log to observability.sqlite and return gracefully (don't crash parent)"
    - "MCP cross-calls retry on ECONNRESET/ETIMEDOUT with 30s timeout"
    - "MCP tool errors return isError=true with full error details"
    - "Integration failures logged with trace IDs for cross-referencing"
  artifacts:
    - path: "src/plugins/hook-executor.ts"
      provides: "Hook error boundary wrapper, safe hook registration"
      min_lines: 100
      exports: ["wrapHookWithErrorBoundary", "registerSafeHook", "logHookFailure"]
    - path: "src/plugins/hook-executor.test.ts"
      provides: "Hook error boundary validation tests"
      min_lines: 60
    - path: "src/agents/sdk-runner/mcp-servers.ts"
      provides: "MCP servers with retry + timeout + error boundaries"
      contains: "retryWithBackoff.*mcp"
  key_links:
    - from: "src/plugins/hook-executor.ts"
      to: "observability.sqlite"
      via: "better-sqlite3 insert"
      pattern: "INSERT INTO events.*hook.*error"
    - from: "src/agents/sdk-runner/mcp-servers.ts"
      to: "src/agents/retry-logic.ts"
      via: "retryWithBackoff wrapper"
      pattern: "retryWithBackoff.*kb_query"
    - from: "src/agents/sdk-runner/mcp-servers.ts"
      to: "src/agents/timeout-enforcement.ts"
      via: "callWithTimeout wrapper"
      pattern: "callWithTimeout.*MCP_TIMEOUT_MS"
---

<objective>
Prevent hook failures from crashing parent processes and make MCP calls resilient to connection issues by wrapping all hooks in error boundaries and adding retry/timeout to MCP operations.

Purpose: Eliminate two critical failure modes: (1) hook exceptions propagating to event loop and crashing Gateway, (2) MCP calls failing permanently on transient connection issues.

Output: Hook executor module with error boundaries, updated MCP servers with retry/timeout wrappers, comprehensive error logging to observability.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/17-integration-reliability/17-CONTEXT.md
@.planning/phases/17-integration-reliability/17-RESEARCH.md
@.planning/phases/17-integration-reliability/17-01-PLAN.md
@src/plugins/hooks.ts
@src/plugins/hook-runner-global.ts
@src/agents/sdk-runner/mcp-servers.ts
@src/agents/retry-logic.ts
@src/agents/timeout-enforcement.ts
</context>

<interfaces>
<!-- Existing hook types from codebase -->

From src/plugins/hooks.ts (existing):

```typescript
// Hook registration (likely exists in some form)
export type HookHandler = (event: HookEvent) => Promise<void> | void;

export interface HookEvent {
  type: string;
  action: string;
  sessionKey: string;
  // ... other fields
}
```

From src/agents/retry-logic.ts (created in 17-01):

```typescript
export function retryWithBackoff<T>(
  operation: () => Promise<T>,
  context: { name: string; circuitKey?: string },
): Promise<T>;
```

From src/agents/timeout-enforcement.ts (created in 17-01):

```typescript
export function callWithTimeout<T>(
  operation: (signal: AbortSignal) => Promise<T>,
  timeoutMs: number,
  context: string,
): Promise<T>;

export const MCP_TIMEOUT_MS = 30_000;
```

From src/agents/sdk-runner/mcp-servers.ts (existing from Phase 16):

```typescript
// Error boundary pattern already exists
function withErrorBoundary<T>(
  toolName: string,
  handler: (input: T) => Promise<{ content: Array<{ type: string; text: string }> }>,
): (input: T) => Promise<{ content: Array<{ type: string; text: string }>; isError?: boolean }>;
```

</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create hook error boundary wrapper</name>
  <files>src/plugins/hook-executor.ts, src/plugins/hook-executor.test.ts</files>
  <action>
Create `src/plugins/hook-executor.ts` implementing:

**Core functions:**

- `wrapHookWithErrorBoundary(hookName: string, handler: HookHandler): HookHandler` — Wrap hook handler in try/catch, log errors to observability, return gracefully without throwing.
- `registerSafeHook(hookName: string, handler: HookHandler)` — Wrap handler with error boundary and register with existing hook system.
- `logHookFailure(params: { hookName: string; eventType: string; eventAction: string; sessionKey: string; error: string; stack?: string; timestamp: number })` — Log to observability.sqlite events table.

**Implementation:**

```typescript
import { createSubsystemLogger } from "../logging/subsystem.js";
import type { HookHandler, HookEvent } from "./hooks.js";

const log = createSubsystemLogger("hook-executor");

export function wrapHookWithErrorBoundary(hookName: string, handler: HookHandler): HookHandler {
  return async (event: HookEvent) => {
    try {
      await handler(event);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorStack = error instanceof Error ? error.stack : undefined;

      log.error(
        `[hook-error] ${hookName} failed for ${event.type}:${event.action} ` +
          `session=${event.sessionKey}: ${errorMessage}`,
      );

      logHookFailure({
        hookName,
        eventType: event.type,
        eventAction: event.action,
        sessionKey: event.sessionKey,
        error: errorMessage,
        stack: errorStack,
        timestamp: Date.now(),
      });

      // CRITICAL: Don't throw—hook failures shouldn't block main operation
    }
  };
}

export function logHookFailure(params: {
  hookName: string;
  eventType: string;
  eventAction: string;
  sessionKey: string;
  error: string;
  stack?: string;
  timestamp: number;
}) {
  try {
    const Database = require("better-sqlite3");
    const path = require("node:path");
    const dbPath = path.join(process.env.HOME ?? "/tmp", ".openclaw", "observability.sqlite");
    const db = new Database(dbPath);
    db.pragma("busy_timeout = 5000");

    db.prepare(
      `
      INSERT INTO events (timestamp, category, event_type, metadata)
      VALUES (?, 'hook', 'error', ?)
    `,
    ).run(
      params.timestamp,
      JSON.stringify({
        hook_name: params.hookName,
        event_type: params.eventType,
        event_action: params.eventAction,
        session_key: params.sessionKey,
        error: params.error,
        stack: params.stack,
      }),
    );

    db.close();
  } catch {
    // Don't crash if observability logging fails
    log.warn("[observability] Failed to log hook failure");
  }
}

export function registerSafeHook(hookName: string, handler: HookHandler) {
  const wrappedHandler = wrapHookWithErrorBoundary(hookName, handler);
  // Import and call existing registerHook function
  const { registerHook } = require("./hooks.js");
  registerHook(hookName, wrappedHandler);
}
```

Create `src/plugins/hook-executor.test.ts` with vitest tests:

- wrapHookWithErrorBoundary catches and logs errors
- wrapHookWithErrorBoundary doesn't throw on handler error (returns gracefully)
- logHookFailure writes to observability.sqlite with correct schema
- registerSafeHook wraps handler before registering
- Multiple hook errors don't crash process (error isolation)
  </action>
  <verify>
  <automated>pnpm test src/plugins/hook-executor.test.ts --run</automated>
  </verify>
  <done>
- `src/plugins/hook-executor.ts` exports wrapHookWithErrorBoundary, registerSafeHook, logHookFailure
- 5+ tests passing validating error boundary behavior, observability logging
- Hook errors logged with full context (hook name, event type, session key, stack trace)
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add retry and timeout to MCP tool implementations</name>
  <files>src/agents/sdk-runner/mcp-servers.ts, src/agents/sdk-runner/mcp-servers.test.ts</files>
  <action>
Update `src/agents/sdk-runner/mcp-servers.ts` to add retry and timeout to MCP tool implementations:

**Imports to add:**

```typescript
import { retryWithBackoff } from "../retry-logic.js";
import { callWithTimeout, MCP_TIMEOUT_MS } from "../timeout-enforcement.js";
```

**Update existing MCP tools** to wrap operations in retry + timeout:

The existing code has `withErrorBoundary()` wrapper (from Phase 16). Add retry + timeout INSIDE the error boundary:

```typescript
// Before (Phase 16):
withErrorBoundary("kb_query", async ({ query, limit }) => {
  const results = kbQuery(query, limit ?? 5);
  return { content: [{ type: "text", text: JSON.stringify(results, null, 2) }] };
});

// After (Phase 17):
withErrorBoundary("kb_query", async ({ query, limit }) => {
  const results = await retryWithBackoff(
    async () =>
      callWithTimeout(
        async (signal) => kbQuery(query, limit ?? 5, { signal }),
        MCP_TIMEOUT_MS,
        "mcp:kb_query",
      ),
    { name: "mcp:kb_query", circuitKey: "mcp-kb-server" },
  );
  return { content: [{ type: "text", text: JSON.stringify(results, null, 2) }] };
});
```

**Apply to all 12 MCP tools:**

- KB tools: kb_query, kb_article, kb_recent, kb_stats, kb_entities, kb_graph, kb_decisions, kb_playbooks, kb_contradictions, kb_smart_query, kb_communities
- System tools: system_info

**Key details:**

- Circuit breaker key: "mcp-kb-server" (shared across all KB tools—if server is down, all fail together)
- Pass AbortSignal to underlying functions if they support cancellation
- Keep existing withErrorBoundary wrapper (don't remove Phase 16 error handling)
- Layer order: withErrorBoundary → retryWithBackoff → callWithTimeout → actual operation

Update `src/agents/sdk-runner/mcp-servers.test.ts`:

- Add test: MCP tool retries on transient failure
- Add test: MCP tool times out after 30s
- Add test: Circuit breaker opens after 5 KB server failures
- Verify existing error boundary tests still pass
  </action>
  <verify>
  <automated>pnpm test src/agents/sdk-runner/mcp-servers.test.ts --run</automated>
  </verify>
  <done>
- All 12 MCP tools wrapped in retry + timeout layers
- MCP calls timeout after 30s using AbortController
- Transient failures retry up to 3 times
- Circuit breaker prevents retry storms
- Existing error boundary behavior preserved (isError=true on failure)
- 3+ new tests validating retry, timeout, circuit breaker
  </done>
  </task>

<task type="auto">
  <name>Task 3: Apply hook error boundaries to all hook registrations</name>
  <files>src/plugins/hooks.ts, src/plugins/hook-runner-global.ts</files>
  <action>
Find all hook registrations in the codebase and wrap with error boundaries:

**Search for hook registrations:**

```bash
grep -r "registerHook\|registerInternalHook" src/plugins/ src/agents/ --include="*.ts" | grep -v test | grep -v "\.d\.ts"
```

**For each hook registration found:**

Replace:

```typescript
registerHook("PreToolUse", async (event) => {
  // ... hook logic ...
});
```

With:

```typescript
import { registerSafeHook } from "./hook-executor.js";

registerSafeHook("PreToolUse", async (event) => {
  // ... hook logic (unchanged) ...
});
```

**Priority hooks to wrap (based on codebase search):**

- PreToolUse (if exists)
- PostToolUse (if exists)
- SessionStart (if exists)
- SessionEnd (if exists)
- BeforeAgentStart (if exists)

**Verification:**

- All wrapped hooks should log errors to observability on failure
- Parent process should not crash when hooks throw
- Hook failures should not block the main operation (e.g., tool execution still completes)

**Documentation:**
Add comment at each wrapped hook explaining the error boundary:

```typescript
// Wrapped with error boundary—hook failures log to observability but don't crash Gateway
registerSafeHook("PostToolUse", async (event) => {
  // ...
});
```

  </action>
  <verify>
    <automated>grep -r "registerSafeHook" src/plugins/ src/agents/ --include="*.ts" | wc -l</automated>
  </verify>
  <done>
- All critical hooks wrapped with registerSafeHook
- Hook error boundaries prevent parent process crashes
- Observability events logged for all hook failures
- Documentation comments explain error boundary behavior
- Existing hook functionality unchanged (backward compatible)
  </done>
</task>

</tasks>

<verification>
**Behavioral validation:**
- Trigger hook error and verify parent process doesn't crash
- Check observability.sqlite for hook error events
- Trigger MCP transient failure and verify retry with backoff
- Trigger MCP timeout and verify abort after 30s
- Verify circuit breaker opens after 5 MCP failures

**Integration validation:**

- All hooks still execute successfully (backward compatible)
- MCP tools return correct results with retry/timeout wrappers
- Observability events include full context (hook name, error, stack trace)
- Error boundaries don't hide legitimate errors (isError=true still returned)
  </verification>

<success_criteria>

- [ ] `src/plugins/hook-executor.ts` created with error boundary wrappers
- [ ] All critical hooks wrapped with registerSafeHook
- [ ] All 12 MCP tools wrapped in retry + timeout layers
- [ ] Hook failures log to observability.sqlite with full context
- [ ] MCP calls retry on ECONNRESET/ETIMEDOUT
- [ ] MCP calls timeout after 30s
- [ ] Circuit breaker prevents MCP retry storms
- [ ] Parent process doesn't crash on hook errors
- [ ] 8+ new tests validating hook boundaries, MCP retry/timeout
      </success_criteria>

<output>
After completion, create `.planning/phases/17-integration-reliability/17-03-SUMMARY.md`
</output>
