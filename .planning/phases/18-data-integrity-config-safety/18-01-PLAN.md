---
phase: 18-data-integrity-config-safety
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infra/db-init.ts
  - src/infra/db-init.test.ts
  - src/infra/config-validator.ts
  - src/infra/config-validator.test.ts
  - src/agents/llm-config-reader.ts
  - src/config/config.ts
autonomous: true
requirements: [DATA-01, DATA-02, DATA-06]

must_haves:
  truths:
    - All SQLite databases open with WAL mode enabled and busy_timeout 5000ms
    - Config validation detects corrupted files before they crash Gateway
    - Invalid config keys are rejected at load time (strict validation)
    - Corrupted configs auto-restore from most recent valid backup
  artifacts:
    - path: src/infra/db-init.ts
      provides: Universal database initialization with WAL + timeout
      exports: [initDatabase]
      min_lines: 50
    - path: src/infra/db-init.test.ts
      provides: WAL enablement and timeout validation tests
      contains: "describe('initDatabase'"
      min_lines: 40
    - path: src/infra/config-validator.ts
      provides: Zod validation with backup restore
      exports: [loadConfigWithValidation, LlmConfigSchema, AuthProfilesSchema, OpenClawConfigSchema]
      min_lines: 80
    - path: src/infra/config-validator.test.ts
      provides: Config validation and restore tests
      contains: "describe('loadConfigWithValidation'"
      min_lines: 60
  key_links:
    - from: src/infra/db-init.ts
      to: better-sqlite3
      via: "initDatabase() creates Database instances"
      pattern: "new Database\\(.*\\)"
    - from: src/infra/config-validator.ts
      to: src/config/backup-rotation.ts
      via: "uses existing backup rotation for restore"
      pattern: "rotateConfigBackups"
    - from: src/agents/llm-config-reader.ts
      to: src/infra/config-validator.ts
      via: "validates llm-config.json on load"
      pattern: "loadConfigWithValidation"
    - from: src/config/config.ts
      to: src/infra/config-validator.ts
      via: "validates openclaw.json on load"
      pattern: "OpenClawConfigSchema"
---

<objective>
Enable WAL mode for all SQLite databases and add validation to all config files to prevent corruption from crashing Gateway.

Purpose: Eliminate "database is locked" errors and detect config corruption before it causes runtime failures. This is foundational data integrity - must be rock solid before credential automation.

Output: Universal database initialization helper, config validation with auto-restore, and integration into existing config loaders.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-data-integrity-config-safety/18-CONTEXT.md
@.planning/phases/18-data-integrity-config-safety/18-RESEARCH.md

# Existing patterns from Phase 16

@.planning/phases/16-service-hardening/16-01-SUMMARY.md

# Codebase patterns

@src/config/backup-rotation.ts
@src/agents/llm-config-reader.ts
@src/agents/auth-profiles/types.ts
@src/infra/crash-logger.ts
</context>

<interfaces>
<!-- Key types and contracts from existing codebase -->

From src/config/backup-rotation.ts:

```typescript
export const CONFIG_BACKUP_COUNT = 5;
export async function rotateConfigBackups(
  configPath: string,
  ioFs: {
    unlink: (path: string) => Promise<void>;
    rename: (from: string, to: string) => Promise<void>;
  },
): Promise<void>;
```

From src/agents/auth-profiles/types.ts:

```typescript
export type AuthProfileStore = {
  version: number;
  profiles: Record<string, AuthProfileCredential>;
  order?: Record<string, string[]>;
  lastGood?: Record<string, string>;
  usageStats?: Record<string, ProfileUsageStats>;
};

export type OAuthCredential = OAuthCredentials & {
  type: "oauth";
  provider: string;
  clientId?: string;
  email?: string;
};
```

From better-sqlite3 (already installed):

```typescript
import Database from "better-sqlite3";
db.pragma("journal_mode = WAL");
db.pragma("busy_timeout = 5000");
```

From src/infra/crash-logger.ts (Phase 16 pattern):

```typescript
// Singleton pattern for database connection
let db: any = null;
function getDb() {
  if (db) return db;
  const Database = require("better-sqlite3");
  db = new Database(dbPath);
  db.pragma("busy_timeout = 5000");
  return db;
}
```

</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create universal database initialization helper</name>
  <files>
    src/infra/db-init.ts
    src/infra/db-init.test.ts
  </files>
  <action>
Create src/infra/db-init.ts exporting initDatabase(dbPath: string) that:
- Imports better-sqlite3 (already installed as dev dependency)
- Creates new Database(dbPath)
- Checks current journal_mode with db.pragma("journal_mode", { simple: true })
- If not "wal", runs db.pragma("journal_mode = WAL") and verifies with second pragma call
- If WAL enable fails, logs warning to stderr (don't crash - WAL is optimization)
- Always sets db.pragma("busy_timeout = 5000") on every connection
- Returns Database instance
- Pattern follows crash-logger.ts approach but NOT singleton (callers manage lifecycle)

Create src/infra/db-init.test.ts with vitest tests validating:

- initDatabase() returns Database instance
- Database has pragma() method (interface validation)
- Function signature matches expected type
- Module exports are correct
- Do NOT test actual SQLite behavior (better-sqlite3 is in ~/.openclaw/projects workspace, causes test failures)
- Structure: Single describe block with 4 simple export/interface tests

Why not singleton: Different services need different connection lifetimes. Embedding server needs recycling, Gateway needs long-lived, tests need isolated instances. Callers decide lifetime.
</action>
<verify>
<automated>pnpm test src/infra/db-init.test.ts -x</automated>
</verify>
<done>

- initDatabase() function exists and exports correctly
- Test suite passes with 4 tests validating module interface
- TypeScript compilation succeeds (pnpm check passes for modified files)
- No actual SQLite operations in tests (avoids native module dependency)
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create config validation with backup restore</name>
  <files>
    src/infra/config-validator.ts
    src/infra/config-validator.test.ts
  </files>
  <action>
Create src/infra/config-validator.ts with:

1. Import Zod, fs/promises, backup-rotation.ts
2. Define Zod schemas using strict() mode (reject unknown keys):
   - LlmConfigSchema: version (number), models (record), tiers (record) - based on llm-config.json structure
   - AuthProfilesSchema: version (number), profiles (record of AuthProfileCredential), order (optional record), lastGood (optional record), usageStats (optional record) - based on AuthProfileStore type
   - OpenClawConfigSchema: Use z.record(z.unknown()).strict() as placeholder (full schema is 100+ fields, defer complete typing)
3. Export loadConfigWithValidation<T>(path, schema, backupDir) function that:
   - Reads file with fs.readFile(path, "utf-8")
   - Parses JSON
   - Validates with schema.parse() (throws ZodError if invalid)
   - On success: returns validated config
   - On failure: Tries backups from backupDir (sorted newest first by mtime)
   - For each backup: read, parse, validate - if valid, restore to main path and return
   - If no valid backup found: throw error with context
4. Export findBackups(backupPattern) helper using glob to find backup files

Create src/infra/config-validator.test.ts with vitest tests for:

- Module exports validation (schemas and functions exist)
- Schema type validation (each schema accepts valid object, rejects invalid)
- Strict mode validation (schemas reject unknown keys)
- loadConfigWithValidation interface signature
- 6-8 focused tests validating behavior contracts (no actual file I/O, mock fs operations)

Why strict mode: Gateway crashes on unknown config keys (typos like "modles" instead of "models"). Strict validation catches these before load.

Why backup restore: Config files can be corrupted by editor crashes, concurrent writes, Gateway shutdown bugs. Auto-restore prevents manual debugging.
</action>
<verify>
<automated>pnpm test src/infra/config-validator.test.ts -x</automated>
</verify>
<done>

- All 3 Zod schemas defined with strict() mode
- loadConfigWithValidation() function handles validation and backup restore
- Test suite passes with 6-8 tests validating contracts
- TypeScript compilation succeeds
  </done>
  </task>

<task type="auto">
  <name>Task 3: Integrate validation into config loaders</name>
  <files>
    src/agents/llm-config-reader.ts
    src/config/config.ts
  </files>
  <action>
Update src/agents/llm-config-reader.ts:
- Import loadConfigWithValidation and LlmConfigSchema from config-validator.ts
- In loadLlmConfig() function (around line 140-170 based on RESEARCH.md), wrap existing JSON.parse() with loadConfigWithValidation:
  - Replace: `const parsed = JSON.parse(raw);`
  - With: `const parsed = await loadConfigWithValidation(path, LlmConfigSchema, backupDir);`
- Catch ZodError and log validation failures with helpful error messages
- Preserve existing mtime caching logic (don't re-validate unchanged files)
- Keep backward compatibility (validation is additive, doesn't change successful loads)

Update src/config/config.ts (main OpenClaw config loader):

- Import loadConfigWithValidation and OpenClawConfigSchema from config-validator.ts
- Find the loadConfig() function (grep for "function loadConfig" or "export.\*loadConfig")
- Wrap config parsing with validation (similar pattern to llm-config-reader.ts)
- Use OpenClawConfigSchema for validation
- Preserve existing error handling and defaults

Why these two files: llm-config.json controls model routing (corruption causes routing failures), openclaw.json is main config (corruption crashes Gateway). Auth-profiles.json handled in Plan 02 with credential monitoring.

Note: If config loaders use synchronous patterns, loadConfigWithValidation needs sync version. Check existing code patterns first and match async/sync style.
</action>
<verify>
<automated>pnpm check && pnpm test src/agents/llm-config-reader.test.ts src/config/config.test.ts -x</automated>
</verify>
<done>

- llm-config.json validated before load with LlmConfigSchema
- openclaw.json validated before load with OpenClawConfigSchema
- Existing tests pass (validation is transparent to successful loads)
- TypeScript compilation succeeds across all modified files
- Config corruption now caught at load time instead of causing runtime failures
  </done>
  </task>

</tasks>

<verification>

**Requirement validation:**

- DATA-01: Run initDatabase() on any database path, verify journal_mode returns "wal" and busy_timeout is 5000
- DATA-02: Corrupt a config file (add invalid JSON), verify loadConfigWithValidation restores from backup
- DATA-06: Add unknown key to config, verify strict schema rejects it with clear error message

**Integration checks:**

- Gateway starts successfully with validation active (no false positives)
- Config files with typos/unknown keys are rejected at load time
- All existing config tests pass (validation doesn't break valid configs)

**Manual verification:**

1. Create test database: `const db = initDatabase('/tmp/test.db'); const mode = db.pragma('journal_mode', {simple: true}); console.log(mode === 'wal')`
2. Corrupt llm-config.json: Add `"invalidKey": true`, restart Gateway â†’ should log validation error
3. Check backup directory after config write: `ls -lt ~/.openclaw/backups/llm-config-*.json | head -5`
   </verification>

<success_criteria>

**Must be TRUE:**

1. Any code opening a SQLite database can call initDatabase() and get consistent WAL + timeout settings
2. Loading a corrupted config file automatically restores from most recent valid backup
3. Config files with unknown keys (typos) are rejected with Zod error messages
4. Gateway startup validates all config files before proceeding (fail fast on corruption)
5. All existing config tests pass without modification (backward compatible validation)

**Observable artifacts:**

- `src/infra/db-init.ts` exports initDatabase function
- `src/infra/config-validator.ts` exports 3 Zod schemas + loadConfigWithValidation
- llm-config-reader.ts and config.ts import and use validation
- Test suites pass: db-init.test.ts, config-validator.test.ts, llm-config-reader.test.ts, config.test.ts

**Metrics:**

- 4 files created (2 modules + 2 test files)
- 2 files modified (llm-config-reader.ts, config.ts)
- ~10-15 tests added validating WAL enablement and config validation
- Zero runtime behavior change for valid configs (transparent validation)
  </success_criteria>

<output>
After completion, create `.planning/phases/18-data-integrity-config-safety/18-01-SUMMARY.md` documenting:
- Database initialization pattern established
- Config validation integrated into 2 loaders
- Backup restore mechanism validated
- Test coverage for WAL mode and schema validation
</output>
