---
phase: 19-monitoring-alerting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infra/health-check.ts
  - src/infra/health-check.test.ts
  - scripts/health-check.sh
autonomous: true
requirements: [OBS-01, OBS-02, OBS-04]

must_haves:
  truths:
    - "Health check command returns status for all services, APIs, and databases"
    - "Service crash detection logs to observability.sqlite within 1 minute"
    - "Config corruption is caught before system becomes unstable"
  artifacts:
    - path: "src/infra/health-check.ts"
      provides: "Comprehensive health check covering services, APIs, databases, config"
      exports: ["checkSystemHealth", "ServiceStatus", "HealthReport"]
      min_lines: 200
    - path: "scripts/health-check.sh"
      provides: "CLI wrapper for health checks"
      min_lines: 30
  key_links:
    - from: "health-check.ts"
      to: "observability.sqlite events table"
      via: "INSERT health check results"
      pattern: "INSERT INTO events.*health_check"
    - from: "health-check.ts"
      to: "crash-logger.ts"
      via: "imports logServiceCrash"
      pattern: "import.*crash-logger"
---

<objective>
Build comprehensive health check system covering all PAIOS components with automated status detection.

Purpose: Detect all failures immediately by checking service status, API connectivity, database health, and config validity on demand and via scheduled checks.

Output: Health check module with TypeScript implementation, test scaffold, and CLI wrapper script. Integrates with existing observability.sqlite for health event logging.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<!-- Existing infrastructure to leverage -->

@src/infra/crash-logger.ts
@src/infra/memory-monitor.ts
@src/infra/credential-monitor.ts
</context>

<interfaces>
<!-- Key patterns from existing infrastructure -->

From src/infra/crash-logger.ts:

```typescript
export function logServiceCrash(params: CrashLogParams): void;
// Writes to observability.sqlite events table:
// category: 'system', event_type: 'service_crash'
```

From src/infra/credential-monitor.ts:

```typescript
import notifier from "node-notifier";
notifier.notify({
  title: "PAIOS Alert",
  message: "...",
  sound: true,
});
```

Observability.sqlite schema:

```sql
CREATE TABLE events (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  trace_id TEXT NOT NULL,
  timestamp TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
  category TEXT NOT NULL,
  action TEXT NOT NULL,
  source TEXT,
  metadata TEXT,
  duration_ms INTEGER,
  error TEXT
);
```

Launchd services (9 total):

- ai.openclaw.gateway (port 18789)
- ai.openclaw.embedding-server (port 11435)
- ai.openclaw.file-watcher
- ai.openclaw.emit-server
- ai.openclaw.daily-tasks (calendar)
- ai.openclaw.weekly-tasks (calendar)
- ai.openclaw.mcp-kb-server (session-scoped, not daemon)
- ai.openclaw.mcp-observability-server (session-scoped)
- ai.openclaw.mcp-macos-system (session-scoped)
  </interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create health check module with comprehensive component coverage</name>
  <files>src/infra/health-check.ts</files>
  <action>
Create health-check.ts module with checkSystemHealth() function covering:

**Services (via launchctl):**

- Check all 9 launchd services (gateway, embedding-server, file-watcher, emit-server, daily-tasks, weekly-tasks, 3 MCP servers)
- Parse `launchctl list | grep ai.openclaw` for PID status
- Calendar services show PID "-" between runs (normal, not failure)
- Record: service name, running (boolean), pid, last exit code

**APIs (via HTTP health checks):**

- Gateway: `http://localhost:18789/health` (or check port is listening)
- Embedding server: `http://localhost:11435/health` (or check port)
- External APIs from auth-profiles.json: Anthropic, OpenAI, Codex, Google, Brave, ElevenLabs, Deepgram, Late
- Use fetch with 5-second timeout, record: api name, status code, latency_ms, available (boolean)

**Databases (via better-sqlite3):**

- Check 5 databases: observability.sqlite, social-history.sqlite, autonomy.sqlite, memory/main.sqlite, projects/knowledge-base/kb.sqlite
- For each: verify file exists, attempt connection, check WAL mode enabled, record: db name, exists, accessible, wal_enabled, size_mb

**Config files (via Zod validation):**

- Load and validate: llm-config.json, auth-profiles.json, openclaw.json
- Use existing validation from Phase 18 (loadConfigWithValidationSync)
- Record: config name, valid (boolean), error message if invalid

**Return type:**

```typescript
export interface ServiceStatus {
  name: string;
  running: boolean;
  pid?: number;
  lastExitCode?: number;
}

export interface ApiStatus {
  name: string;
  available: boolean;
  statusCode?: number;
  latency_ms?: number;
  error?: string;
}

export interface DatabaseStatus {
  name: string;
  exists: boolean;
  accessible: boolean;
  wal_enabled?: boolean;
  size_mb?: number;
  error?: string;
}

export interface ConfigStatus {
  name: string;
  valid: boolean;
  error?: string;
}

export interface HealthReport {
  timestamp: string;
  services: ServiceStatus[];
  apis: ApiStatus[];
  databases: DatabaseStatus[];
  configs: ConfigStatus[];
  overall: "healthy" | "degraded" | "critical";
}

export async function checkSystemHealth(): Promise<HealthReport>;
```

**Overall status derivation:**

- critical: Any core service down (gateway, embedding-server) OR any config invalid
- degraded: Any non-core service down OR any API unavailable OR any database inaccessible
- healthy: All checks pass

**Integration:**

- Log health check results to observability.sqlite (category: 'monitoring', action: 'health_check')
- Use crash-logger pattern for database access (singleton better-sqlite3)
- Graceful degradation: If observability DB unavailable, log to stderr but return health report

**Path resolution:**

- Databases: `~/.openclaw/{name}.sqlite` except KB at `~/.openclaw/projects/knowledge-base/kb.sqlite`
- Config files: `~/.openclaw/{name}.json`
- Use `path.join(process.env.HOME ?? "/tmp", ".openclaw", ...)` pattern from crash-logger
  </action>
  <verify>
  <automated>
  pnpm test src/infra/health-check.test.ts
  </automated>
  </verify>
  <done>
  HealthReport type exported with all status interfaces, checkSystemHealth() returns report with all 4 check categories, overall status correctly derived from component statuses
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create test scaffold with placeholder tests for all health check categories</name>
  <files>src/infra/health-check.test.ts</files>
  <action>
Create test scaffold following Phase 16 pattern (single placeholder test + todo markers):

```typescript
import { describe, test, expect } from "vitest";
import { checkSystemHealth } from "./health-check.js";

describe("health-check", () => {
  test("checkSystemHealth returns HealthReport structure", async () => {
    const report = await checkSystemHealth();

    expect(report).toHaveProperty("timestamp");
    expect(report).toHaveProperty("services");
    expect(report).toHaveProperty("apis");
    expect(report).toHaveProperty("databases");
    expect(report).toHaveProperty("configs");
    expect(report).toHaveProperty("overall");
    expect(["healthy", "degraded", "critical"]).toContain(report.overall);
  });

  // TODO: Test service status detection (mock launchctl output)
  // TODO: Test API health checks (mock fetch responses)
  // TODO: Test database accessibility (mock better-sqlite3)
  // TODO: Test config validation (mock file reads)
  // TODO: Test overall status derivation (critical/degraded/healthy)
  // TODO: Test observability logging (verify events table INSERT)
});
```

**Test discovery validation:**

- Ensure vitest can discover and run the test
- Placeholder test MUST pass (validates structure only)
- Todo markers document expected behavior for future implementation
  </action>
  <verify>
  <automated>
  pnpm test src/infra/health-check.test.ts
  </automated>
  </verify>
  <done>
  Test file compiles without errors, vitest discovers test, placeholder test passes, 6 TODO markers present documenting expected test coverage
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create CLI wrapper script for manual and scheduled health checks</name>
  <files>scripts/health-check.sh</files>
  <action>
Create health-check.sh Bash script that:

**Core functionality:**

- Runs `bun src/infra/health-check.ts` (direct TypeScript execution via Bun)
- Captures JSON output from checkSystemHealth()
- Formats output for human readability (color-coded status indicators)
- Returns exit code: 0 = healthy, 1 = degraded, 2 = critical

**Output format:**

```
PAIOS Health Check (2026-02-28 14:30:00)

Services (9):
  ✓ gateway (pid 9568)
  ✓ embedding-server (pid 12345)
  ✗ file-watcher (not running, last exit: 1)
  ...

APIs (8):
  ✓ anthropic (200, 45ms)
  ✓ openai (200, 67ms)
  ✗ brave (timeout)
  ...

Databases (5):
  ✓ observability.sqlite (WAL, 1.8MB)
  ✓ social-history.sqlite (WAL, 14MB)
  ...

Configs (3):
  ✓ llm-config.json
  ✓ auth-profiles.json
  ✗ openclaw.json (validation error: invalid key 'foo')

Overall: DEGRADED
```

**Color coding (ANSI escape codes):**

- Green ✓ for healthy components
- Yellow ! for degraded components
- Red ✗ for failed components
- Use `tput setaf` for portable colors (bash 3.2 compatible)

**Executable permissions:**

- chmod +x in the commit
- Shebang: `#!/usr/bin/env bash`

**Error handling:**

- If Bun not available, fall back to Node.js: `node --loader ts-node/esm src/infra/health-check.ts`
- If health check throws, exit 2 (critical) and print error
  </action>
  <verify>
  <automated>
  bash -n scripts/health-check.sh && echo "Syntax OK"
  </automated>
  </verify>
  <done>
  Script has no syntax errors, executable permission set, runs successfully and prints formatted health report, exit code reflects overall health status
  </done>
  </task>

</tasks>

<verification>
Manual verification after implementation:
1. Run `pnpm test src/infra/health-check.test.ts` — placeholder test passes
2. Run `scripts/health-check.sh` — formatted report displays
3. Check observability.sqlite: `sqlite3 ~/.openclaw/observability.sqlite "SELECT * FROM events WHERE action='health_check' ORDER BY id DESC LIMIT 1"` — row exists with metadata JSON
4. Stop gateway: `launchctl stop ai.openclaw.gateway`, run health check again — overall status becomes "critical"
</verification>

<success_criteria>

- checkSystemHealth() returns HealthReport with all 4 component categories populated
- Overall status correctly derived: critical if core service/config fails, degraded if non-core fails, healthy otherwise
- Health check results logged to observability.sqlite events table
- CLI script formats output with color-coded status indicators
- Test scaffold compiles and placeholder test passes
  </success_criteria>

<output>
After completion, create `.planning/phases/19-monitoring-alerting/19-01-SUMMARY.md`
</output>
