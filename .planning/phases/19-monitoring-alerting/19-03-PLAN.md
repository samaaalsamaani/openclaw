---
phase: 19-monitoring-alerting
plan: 03
type: execute
wave: 3
depends_on: [19-01, 19-02]
files_modified:
  - src/cli/commands/status.ts
  - src/infra/status-dashboard.ts
  - src/infra/status-dashboard.test.ts
autonomous: true
requirements: [OBS-07]

must_haves:
  truths:
    - "ai status command shows real-time system health at a glance"
    - "Dashboard displays service status, API availability, recent errors"
  artifacts:
    - path: "src/infra/status-dashboard.ts"
      provides: "Dashboard rendering and data aggregation"
      exports: ["renderDashboard", "DashboardData"]
      min_lines: 150
    - path: "src/cli/commands/status.ts"
      provides: "CLI command integration for ai status"
      min_lines: 40
  key_links:
    - from: "status.ts"
      to: "status-dashboard.ts"
      via: "calls renderDashboard"
      pattern: "import.*renderDashboard"
    - from: "status-dashboard.ts"
      to: "health-check.ts"
      via: "fetches health report"
      pattern: "checkSystemHealth"
    - from: "status-dashboard.ts"
      to: "observability.sqlite"
      via: "queries recent errors"
      pattern: "SELECT.*FROM events.*error"
---

<objective>
Create real-time status dashboard accessible via `ai status` command showing system health at a glance.

Purpose: Provide instant visibility into PAIOS health with formatted dashboard showing services, APIs, databases, recent errors, and overall system status.

Output: Status dashboard module with terminal rendering, CLI command integration, and test scaffold. Leverages health check from Plan 01.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/19-monitoring-alerting/19-01-SUMMARY.md
@.planning/phases/19-monitoring-alerting/19-02-SUMMARY.md
@src/infra/health-check.ts
@src/terminal/table.ts
@src/terminal/palette.ts
</context>

<interfaces>
<!-- Dependencies from prior plans -->
From src/infra/health-check.ts:
```typescript
export interface HealthReport {
  timestamp: string;
  services: ServiceStatus[];
  apis: ApiStatus[];
  databases: DatabaseStatus[];
  configs: ConfigStatus[];
  overall: "healthy" | "degraded" | "critical";
}
export async function checkSystemHealth(): Promise<HealthReport>;
```

From src/terminal/table.ts (existing):

```typescript
// Project uses src/terminal/table.ts for table rendering
// Check implementation for available table formatting utilities
```

From src/terminal/palette.ts (existing):

```typescript
// Project uses src/terminal/palette.ts for color utilities
// Check for available color functions
```

Observability events for recent errors:

```sql
SELECT action, source, error, timestamp
FROM events
WHERE error IS NOT NULL
  AND timestamp > datetime('now', '-24 hours')
ORDER BY timestamp DESC
LIMIT 10;
```

</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create status dashboard module with terminal rendering</name>
  <files>src/infra/status-dashboard.ts</files>
  <action>
Create status-dashboard.ts module with renderDashboard() function:

**Dashboard layout:**

```
╔══════════════════════════════════════════════════════════╗
║              PAIOS System Status                         ║
║              2026-02-28 14:30:00                         ║
╚══════════════════════════════════════════════════════════╝

Overall Health: ● HEALTHY

┌─ Services (9/9 running) ─────────────────────────────────┐
│ ✓ gateway              [9568]  │ ✓ file-watcher    [12345] │
│ ✓ embedding-server    [11234]  │ ✓ emit-server     [12346] │
│ - daily-tasks             [-]  │ - weekly-tasks        [-] │
│ - mcp-kb-server           [-]  │ - mcp-obs-server      [-] │
│ - mcp-macos-system        [-]  │                            │
└──────────────────────────────────────────────────────────┘

┌─ APIs (7/8 available) ───────────────────────────────────┐
│ ✓ anthropic        200  45ms   │ ✓ openai          200  67ms │
│ ✓ codex            200  89ms   │ ✓ google          200  34ms │
│ ✗ brave            timeout     │ ✓ elevenlabs      200  56ms │
│ ✓ deepgram         200  78ms   │ ✓ late            200  123ms │
└──────────────────────────────────────────────────────────┘

┌─ Databases (5/5 accessible) ─────────────────────────────┐
│ ✓ observability.sqlite    WAL   1.8MB                     │
│ ✓ social-history.sqlite   WAL  14.0MB                     │
│ ✓ autonomy.sqlite         WAL   0.1MB                     │
│ ✓ memory/main.sqlite      WAL  13.0MB                     │
│ ✓ kb.sqlite               WAL  55.0MB                     │
└──────────────────────────────────────────────────────────┘

┌─ Recent Errors (last 24 hours) ──────────────────────────┐
│ 14:25  mcp_timeout        KB server timeout (3 times)    │
│ 12:10  sdk_error          ARG_MAX exceeded               │
│ 09:30  integration_fail   Late.dev API 503               │
└──────────────────────────────────────────────────────────┘

Configs: ✓ llm-config.json  ✓ auth-profiles.json  ✓ openclaw.json
```

**Implementation details:**

Use existing project utilities:

- Import table rendering from `src/terminal/table.ts` (check implementation for available helpers)
- Import color functions from `src/terminal/palette.ts` (check for available colors)
- If no table helpers exist, use plain text with ANSI box-drawing characters (─ ┌ ┐ └ ┘ │)

**Data aggregation:**

```typescript
export interface DashboardData {
  health: HealthReport; // from checkSystemHealth()
  recentErrors: Array<{
    timestamp: string;
    action: string;
    source: string;
    error: string;
    count?: number; // if grouped by error type
  }>;
}

export async function renderDashboard(): Promise<string>;
```

**Dashboard logic:**

1. Call checkSystemHealth() for current status
2. Query observability.sqlite for recent errors (last 24 hours)
3. Group errors by type, count occurrences
4. Format into terminal layout with colors
5. Return formatted string

**Color coding:**

- Green ✓ for healthy/available
- Yellow ! for degraded/slow
- Red ✗ for failed/unavailable
- Blue - for calendar services between runs (normal)

**Overall health indicator:**

- ● HEALTHY (green) if overall: "healthy"
- ● DEGRADED (yellow) if overall: "degraded"
- ● CRITICAL (red) if overall: "critical"

**Box drawing:**
Use Unicode box-drawing characters for borders:

- Horizontal: ─
- Vertical: │
- Corners: ┌ ┐ └ ┘
- T-junctions: ├ ┤ ┬ ┴
- Heavy borders: ═ ║ ╔ ╗ ╚ ╝

**Error handling:**

- If health check fails, display "Status check failed: [error]"
- If observability DB unavailable, show "Recent errors: unavailable"
- Never throw — always return formatted output
  </action>
  <verify>
  <automated>
  pnpm test src/infra/status-dashboard.test.ts
  </automated>
  </verify>
  <done>
  renderDashboard() returns formatted terminal output with box-drawing borders, color-coded status indicators, all 4 health categories displayed, recent errors section shows grouped errors from observability.sqlite
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create test scaffold for dashboard rendering</name>
  <files>src/infra/status-dashboard.test.ts</files>
  <action>
Create test scaffold following Phase 16 pattern:

```typescript
import { describe, test, expect } from "vitest";
import { renderDashboard } from "./status-dashboard.js";

describe("status-dashboard", () => {
  test("renderDashboard returns formatted string with sections", async () => {
    const output = await renderDashboard();

    expect(output).toContain("PAIOS System Status");
    expect(output).toContain("Overall Health:");
    expect(output).toContain("Services");
    expect(output).toContain("APIs");
    expect(output).toContain("Databases");
    expect(output).toContain("Recent Errors");
    expect(output).toContain("Configs");
  });

  // TODO: Test service section formatting (mock health report)
  // TODO: Test API section with latency display
  // TODO: Test database section with WAL status
  // TODO: Test recent errors section (mock observability query)
  // TODO: Test color coding (healthy vs degraded vs critical)
  // TODO: Test error handling (health check fails)
});
```

**Test discovery validation:**

- Vitest discovers and runs test
- Placeholder test passes (validates output structure)
- 6 TODO markers document expected coverage
  </action>
  <verify>
  <automated>
  pnpm test src/infra/status-dashboard.test.ts
  </automated>
  </verify>
  <done>
  Test file compiles, vitest discovers test, placeholder test passes, 6 TODO markers present
  </done>
  </task>

<task type="auto">
  <name>Task 3: Integrate status command with CLI</name>
  <files>src/cli/commands/status.ts</files>
  <action>
Create or update status.ts CLI command:

**Command structure:**

```typescript
import { renderDashboard } from "../../infra/status-dashboard.js";

export async function statusCommand(): Promise<void> {
  const dashboard = await renderDashboard();
  console.log(dashboard);
}
```

**CLI integration:**
Check existing CLI command structure in `src/cli/commands/` for patterns:

- Typical pattern: export async function matching command name
- May have CLI framework integration (yargs, commander, etc.)
- Follow existing command patterns for consistency

**If `ai` command exists:**
Add status subcommand to existing CLI:

```bash
ai status  # shows dashboard
```

**If no `ai` command:**
Create standalone status command:

```bash
pnpm openclaw status  # shows dashboard
```

**Error handling:**

- Wrap renderDashboard() in try/catch
- On error, print friendly message: "Status check failed: [error]"
- Exit with code 1 on error, 0 on success

**CLI help text:**

```
Usage: ai status

Display real-time PAIOS system health dashboard showing:
- Service status (launchd processes)
- API availability (response codes and latency)
- Database accessibility (connection + WAL mode)
- Recent errors (last 24 hours from observability)
- Config validation status
```

  </action>
  <verify>
    <automated>
pnpm build && pnpm openclaw status 2>&1 | head -3 | grep -q "PAIOS System Status" && echo "Command works"
    </automated>
  </verify>
  <done>
status.ts CLI command exists, calls renderDashboard(), prints output to stdout, integrated with existing CLI framework, help text available
  </done>
</task>

</tasks>

<verification>
Manual verification after implementation:
1. Run `pnpm openclaw status` or `ai status` — dashboard displays with all sections
2. Verify color coding: healthy components show green ✓, failed show red ✗
3. Stop a service, run status again — service shows as not running
4. Check recent errors section shows actual errors from observability.sqlite
5. Verify box-drawing characters render correctly (not garbled)
</verification>

<success_criteria>

- renderDashboard() returns formatted terminal output with box-drawing borders
- All 4 health categories displayed: services, APIs, databases, configs
- Recent errors section queries observability.sqlite and groups by type
- Color-coded status indicators (green/yellow/red) for component health
- CLI command integrated and accessible via `ai status` or `pnpm openclaw status`
- Test scaffold compiles and placeholder test passes
  </success_criteria>

<output>
After completion, create `.planning/phases/19-monitoring-alerting/19-03-SUMMARY.md`
</output>
