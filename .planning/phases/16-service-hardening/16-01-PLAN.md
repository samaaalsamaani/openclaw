---
phase: 16-service-hardening
plan: 01
type: execute
wave: 1
depends_on:
  - 16-00
files_modified:
  - src/infra/crash-logger.ts
  - src/infra/crash-logger.test.ts
  - src/gateway/server-close.ts
  - src/infra/unhandled-rejections.ts
  - src/agents/sdk-runner/mcp-servers.ts
autonomous: true
requirements:
  - SERV-01
  - SERV-03
  - SERV-06

must_haves:
  truths:
    - "Gateway process can log crashes to observability.sqlite with timestamp, exit code, and service name"
    - "MCP tool errors return isError=true instead of crashing the entire server process"
    - "Unhandled rejections are classified (transient vs fatal) and handled appropriately"
    - "All timers and intervals are tracked and cleared on SIGTERM"
  artifacts:
    - path: "src/infra/crash-logger.ts"
      provides: "Crash logging to observability.sqlite"
      exports: ["logServiceCrash"]
    - path: "src/infra/crash-logger.test.ts"
      provides: "Crash logger validation"
      min_lines: 30
    - path: "src/agents/sdk-runner/mcp-servers.ts"
      provides: "MCP error boundaries with isError responses"
      contains: "isError: true"
  key_links:
    - from: "src/gateway/server-close.ts"
      to: "src/infra/crash-logger.ts"
      via: "process.on('exit') handler"
      pattern: "logServiceCrash"
    - from: "src/agents/sdk-runner/mcp-servers.ts"
      to: "MCP tool handlers"
      via: "try/catch wrapper"
      pattern: "isError.*true"
---

<objective>
Add comprehensive error handling and crash recovery logging to prevent service failures from cascading and to enable root cause analysis when failures occur.

Purpose: Transform silent failures into observable, recoverable events. When services crash, log detailed context to observability.sqlite so patterns can be identified. When MCP tools fail, return structured errors instead of crashing the entire server.

Output:

- Crash logger module integrated into all services
- MCP servers wrapped in error boundaries
- Enhanced SIGTERM handlers with resource cleanup tracking
  </objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-service-hardening/16-CONTEXT.md
@.planning/phases/16-service-hardening/16-RESEARCH.md

# Test scaffolds from Wave 0

@src/infra/crash-logger.test.ts — Pre-created test scaffold with todo markers
@src/gateway/server-close.test.ts — Pre-created test scaffold with todo markers
@src/agents/sdk-runner/mcp-servers.test.ts — Pre-created test scaffold with todo markers

# Key interfaces from existing code

@src/gateway/server-close.ts — Existing graceful shutdown patterns
@src/infra/unhandled-rejections.ts — Transient error classification
@src/agents/sdk-runner/mcp-servers.ts — MCP server implementations

<interfaces>
<!-- Existing shutdown and error handling patterns -->

From src/infra/unhandled-rejections.ts:

```typescript
export function isTransientNetworkError(error: unknown): boolean;
export function isAbortError(error: unknown): boolean;
```

From observability.sqlite schema (existing):

```sql
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  timestamp INTEGER NOT NULL,
  category TEXT NOT NULL,
  event_type TEXT NOT NULL,
  service_name TEXT,
  metadata TEXT
);
```

MCP Tool Response Pattern:

```typescript
type ToolResponse = {
  content: { type: string; text: string }[];
  isError?: boolean;
};
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crash logger with observability.sqlite integration</name>
  <files>
src/infra/crash-logger.ts
src/infra/crash-logger.test.ts
  </files>
  <action>
Create src/infra/crash-logger.ts module that:
1. Opens ~/.openclaw/observability.sqlite with busy_timeout 5000ms (connection pooling pattern — singleton, keep open)
2. Exports logServiceCrash() function accepting: serviceName, exitCode, signal, restartAttempt
3. Inserts to events table with category='system', event_type='service_crash', metadata JSON containing exit details
4. Uses better-sqlite3 prepare() for all queries (performance + safety)
5. Handles SQLite errors gracefully (log to stderr, don't crash on crash logger failure)

Flesh out src/infra/crash-logger.test.ts (scaffold from Plan 16-00) by:

1. Converting it.todo() markers to full test implementations
2. Validating logServiceCrash() inserts row with correct fields
3. Testing multiple crashes are logged independently
4. Testing SQLite connection errors don't throw (degradation)
5. Using in-memory database (:memory:) for test isolation

Pattern: Implement module and tests simultaneously. Test scaffold from Plan 16-00 already defines the contract—fill in the test bodies while building the implementation.

Why not use existing unhandled-rejections.ts: That module classifies errors, this logs crashes — distinct concerns. Crash logger is specifically for process exit events.
</action>
<verify>
<automated>pnpm test src/infra/crash-logger.test.ts --run</automated>
</verify>
<done>Tests pass (all todo markers converted to passing tests). logServiceCrash() function exists and writes to observability.sqlite events table.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate crash logging into Gateway shutdown and add resource tracking</name>
  <files>
src/gateway/server-close.ts
src/gateway/server-close.test.ts
  </files>
  <action>
Update src/gateway/server-close.ts to:
1. Import logServiceCrash from src/infra/crash-logger.ts
2. Add Set<NodeJS.Timeout> to track all active timers/intervals at module level (name: activeTimers)
3. Export registerTimer() and clearTimer() helpers for tracking
4. In existing SIGTERM handler, clear all activeTimers before closing database
5. Add process.on('exit') handler calling logServiceCrash with:
   - serviceName: 'gateway'
   - exitCode: from callback parameter
   - signal: process.env.SHUTDOWN_SIGNAL || null
   - restartAttempt: parseInt(process.env.LAUNCHD_RESTART_COUNT || '0', 10)

Flesh out src/gateway/server-close.test.ts (scaffold from Plan 16-00) by:

1. Converting it.todo() markers to full test implementations
2. Testing timer tracking in activeTimers Set
3. Testing all timers are cleared on shutdown
4. Testing logServiceCrash is called on process exit
5. Mocking process.on() to validate exit handler registration

Pattern: Track resources at creation, clean up in shutdown. Don't modify existing graceful shutdown flow — add tracking layer on top.

Why track timers explicitly: Timers are the #1 memory leak source in long-running Node.js services. Explicit tracking enables validation that all timers are cleared.
</action>
<verify>
<automated>pnpm test src/gateway/server-close.test.ts --run</automated>
<manual>Build Gateway, trigger shutdown via SIGTERM, verify crash log appears in observability.sqlite</manual>
</verify>
<done>Tests pass (all todo markers converted). server-close.ts imports crash-logger, tracks timers in Set, clears on shutdown, logs crashes on exit.</done>
</task>

<task type="auto">
  <name>Task 3: Wrap MCP tool handlers in error boundaries</name>
  <files>
src/agents/sdk-runner/mcp-servers.ts
src/agents/sdk-runner/mcp-servers.test.ts
  </files>
  <action>
Update src/agents/sdk-runner/mcp-servers.ts to wrap all MCP tool handlers:
1. Find all tool() definitions in the file
2. Wrap each handler function body in try/catch
3. On catch: return { isError: true, content: [{ type: "text", text: `Error in [tool_name]: ${error.message}` }] }
4. Log error to console.error with full context (tool name, input parameters, stack trace)
5. Do NOT crash the process — always return structured error response

Flesh out src/agents/sdk-runner/mcp-servers.test.ts (scaffold from Plan 16-00) by:

1. Converting it.todo() markers to full test implementations
2. Testing tool handlers are wrapped in try/catch
3. Testing errors return isError=true
4. Testing server process doesn't crash on tool errors
5. Testing errors are logged with full context
6. Testing other tools continue working after one fails

Example pattern for kb_query tool:

```typescript
tool("kb_query", "Query knowledge base", schema, async (input) => {
  try {
    const results = await queryKB(input);
    return { content: [{ type: "text", text: JSON.stringify(results) }] };
  } catch (error) {
    console.error(`[mcp-error] kb_query failed:`, error);
    return {
      isError: true,
      content: [
        {
          type: "text",
          text: `Knowledge base query failed: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
    };
  }
});
```

Apply this pattern to ALL tool handlers in the file. This prevents any single tool failure from crashing the entire MCP server process.

Why not global error handler: Tool-level error boundaries provide granular context (which tool, what input) and allow other tools to continue working.
</action>
<verify>
<automated>pnpm test src/agents/sdk-runner/mcp-servers.test.ts --run</automated>
<manual>Trigger MCP tool error (bad input), verify server stays up and returns isError=true</manual>
</verify>
<done>Tests pass (all todo markers converted). All MCP tool handlers wrapped in try/catch, return isError=true on failure, log errors without crashing.</done>
</task>

</tasks>

<verification>
**Phase gate checks:**

1. Crash logger integration
   - Run: `pnpm test src/infra/crash-logger.test.ts --run`
   - Expected: All tests pass, crash events written to observability.sqlite

2. Gateway shutdown cleanup
   - Run: `pnpm build && pkill -TERM openclaw-gateway`
   - Expected: observability.sqlite contains exit event, no orphaned timers in logs

3. MCP error resilience
   - Run: `pnpm test src/agents/sdk-runner/mcp-servers.test.ts --run`
   - Expected: Tool errors return isError=true, server process continues

4. Type checking
   - Run: `pnpm check`
   - Expected: No TypeScript errors in modified files
     </verification>

<success_criteria>
**Observable outcomes:**

- Gateway exit events appear in observability.sqlite with exit code, signal, restart count
- MCP tool failures return structured error responses (isError: true) instead of crashing
- SIGTERM handler clears all tracked timers/intervals (no resource leaks)
- Unhandled rejections are logged but don't crash process for transient errors
- All modified files pass TypeScript strict checks and vitest tests
  </success_criteria>

<output>
After completion, create `.planning/phases/16-service-hardening/16-01-SUMMARY.md` documenting:
- Crash logging implementation and observability.sqlite schema usage
- Timer/interval tracking pattern for Gateway shutdown
- MCP error boundary pattern applied to all tools
- Test coverage for crash scenarios
</output>
