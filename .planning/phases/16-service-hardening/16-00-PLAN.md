---
phase: 16-service-hardening
plan: "00"
type: execute
wave: 0
depends_on: []
files_modified:
  - src/infra/crash-logger.test.ts
  - src/gateway/server-close.test.ts
  - src/agents/sdk-runner/mcp-servers.test.ts
  - src/infra/memory-monitor.test.ts
  - src/infra/circuit-breaker.test.ts
autonomous: true
requirements:
  - SERV-01
  - SERV-03

must_haves:
  truths:
    - "Test scaffolds exist for all new infra modules before implementation"
    - "Test files compile and run (even if empty/pending)"
    - "Vitest can discover and execute all test files"
  artifacts:
    - path: "src/infra/crash-logger.test.ts"
      provides: "Crash logger test scaffold"
      min_lines: 10
    - path: "src/gateway/server-close.test.ts"
      provides: "Gateway shutdown test scaffold"
      min_lines: 10
    - path: "src/agents/sdk-runner/mcp-servers.test.ts"
      provides: "MCP error boundary test scaffold"
      min_lines: 10
    - path: "src/infra/memory-monitor.test.ts"
      provides: "Memory monitoring test scaffold"
      min_lines: 10
    - path: "src/infra/circuit-breaker.test.ts"
      provides: "Circuit breaker test scaffold"
      min_lines: 10
  key_links:
    - from: "Plans 16-01 and 16-02"
      to: "Test scaffolds"
      via: "Implement against pre-defined test structure"
      pattern: "import.*test"
---

<objective>
Create minimal test scaffolds for all new infrastructure modules before implementation, following Nyquist principle (tests before code).

Purpose: Test-first development ensures implementations are designed for testability. Scaffolds define the contract—later plans flesh out assertions while building the implementation. This prevents the anti-pattern of writing tests as an afterthought.

Output:

- 5 test scaffold files (crash-logger, server-close, mcp-servers, memory-monitor, circuit-breaker)
- All scaffolds compile and run (with pending/todo markers)
- Vitest can discover and execute all tests
  </objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-service-hardening/16-CONTEXT.md
@.planning/phases/16-service-hardening/16-RESEARCH.md

# Existing test patterns

Look at existing test files for scaffold structure:
@src/daemon/launchd-plist.test.ts
@src/infra/heartbeat-runner.test.ts

<interfaces>
<!-- Vitest test structure -->

From existing test files:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";

describe("ModuleName", () => {
  it("should do something", () => {
    // Test body
    expect(true).toBe(true);
  });

  it.todo("should handle edge case"); // Pending test marker
});
```

Test file naming convention:

- Source: `src/infra/module-name.ts`
- Test: `src/infra/module-name.test.ts`
  </interfaces>
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create crash logger and server shutdown test scaffolds</name>
  <files>
src/infra/crash-logger.test.ts
src/gateway/server-close.test.ts
  </files>
  <action>
Create src/infra/crash-logger.test.ts with minimal structure:
1. Import describe, it, expect, beforeEach from vitest
2. Create describe("crash-logger") block
3. Add it.todo() markers for test cases from RESEARCH.md:
   - "should insert crash event to observability.sqlite"
   - "should log multiple crashes independently"
   - "should handle SQLite connection errors gracefully"
   - "should work with in-memory database for testing"
4. Add one passing placeholder test: it("scaffold exists", () => expect(true).toBe(true))

Create src/gateway/server-close.test.ts with minimal structure:

1. Import describe, it, expect from vitest
2. Create describe("server-close") block
3. Add it.todo() markers:
   - "should track timers in activeTimers Set"
   - "should clear all timers on shutdown"
   - "should log crash on process exit"
   - "should call logServiceCrash with correct parameters"
4. Add one passing placeholder test: it("scaffold exists", () => expect(true).toBe(true))

Pattern: Minimal viable test file—compiles, runs, has structure for later implementation. The todo markers document the contract that implementations must satisfy.

Why scaffold before implementation: Forces thinking about testability up front. Implementation in Plan 16-01 will fill in test bodies while building the module.
</action>
<verify>
<automated>pnpm test src/infra/crash-logger.test.ts src/gateway/server-close.test.ts --run</automated>
</verify>
<done>Both test files exist, compile, run successfully (1 passing test each, rest todo).</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP error boundary test scaffold</name>
  <files>
src/agents/sdk-runner/mcp-servers.test.ts
  </files>
  <action>
Create src/agents/sdk-runner/mcp-servers.test.ts with minimal structure:
1. Import describe, it, expect from vitest
2. Create describe("mcp-servers error boundaries") block
3. Add it.todo() markers for test cases:
   - "should wrap tool handlers in try/catch"
   - "should return isError=true on tool failure"
   - "should not crash server process on tool error"
   - "should log error with full context"
   - "should continue serving other tools after one fails"
4. Add one passing placeholder test: it("scaffold exists", () => expect(true).toBe(true))

Why separate MCP test file: MCP servers are isolated from gateway shutdown concerns. Separate file allows focused testing of error boundary behavior.
</action>
<verify>
<automated>pnpm test src/agents/sdk-runner/mcp-servers.test.ts --run</automated>
</verify>
<done>MCP servers test scaffold exists, compiles, runs successfully (1 passing test, rest todo).</done>
</task>

<task type="auto">
  <name>Task 3: Create memory monitor and circuit breaker test scaffolds</name>
  <files>
src/infra/memory-monitor.test.ts
src/infra/circuit-breaker.test.ts
  </files>
  <action>
Create src/infra/memory-monitor.test.ts with minimal structure:
1. Import describe, it, expect from vitest
2. Create describe("memory-monitor") block
3. Add it.todo() markers for test cases from RESEARCH.md:
   - "should return cleanup function from startMemoryMonitoring"
   - "should track last 12 memory samples in FIFO buffer"
   - "should calculate MB/hour growth rate accurately"
   - "should not alert for growth <10MB/hour"
   - "should alert for growth >10MB/hour"
   - "should stop monitoring on cleanup"
4. Add one passing placeholder test: it("scaffold exists", () => expect(true).toBe(true))

Create src/infra/circuit-breaker.test.ts with minimal structure:

1. Import describe, it, expect from vitest
2. Create describe("CircuitBreaker") block
3. Add it.todo() markers for test cases:
   - "should allow calls in closed state"
   - "should open after 5 consecutive failures"
   - "should stay open for configured timeout"
   - "should transition to half-open after timeout"
   - "should close on success in half-open state"
   - "should reopen on failure in half-open state"
   - "should reject immediately when open (no fn execution)"
4. Add one passing placeholder test: it("scaffold exists", () => expect(true).toBe(true))

Pattern: Test scaffolds define the contract. Plan 16-02 will implement both modules and flesh out these test bodies simultaneously.

Why todo markers instead of empty tests: todo markers show intent without failing CI. Empty tests (it("...", () => {})) pass falsely. Todo markers are discoverable via vitest --reporter=verbose.
</action>
<verify>
<automated>pnpm test src/infra/memory-monitor.test.ts src/infra/circuit-breaker.test.ts --run</automated>
</verify>
<done>Both test scaffolds exist, compile, run successfully (1 passing test each, rest todo).</done>
</task>

</tasks>

<verification>
**Phase gate checks:**

1. All test scaffolds exist
   - Run: `ls -1 src/infra/crash-logger.test.ts src/gateway/server-close.test.ts src/agents/sdk-runner/mcp-servers.test.ts src/infra/memory-monitor.test.ts src/infra/circuit-breaker.test.ts`
   - Expected: All 5 files exist

2. All scaffolds compile and run
   - Run: `pnpm test src/infra/*.test.ts src/gateway/server-close.test.ts src/agents/sdk-runner/mcp-servers.test.ts --run`
   - Expected: 5 passing tests (1 per file), N todo tests, no failures

3. Vitest can discover tests
   - Run: `pnpm test --reporter=verbose --run | grep "scaffold exists"`
   - Expected: 5 occurrences (one per test file)

4. Type checking
   - Run: `pnpm check`
   - Expected: No TypeScript errors
     </verification>

<success_criteria>
**Observable outcomes:**

- 5 test scaffold files exist and compile
- Each scaffold has 1 passing placeholder test
- Each scaffold has todo markers for implementation test cases
- Vitest can discover and execute all test files
- No TypeScript errors in test scaffolds
- Plans 16-01 and 16-02 can reference these test files in their verify sections
  </success_criteria>

<output>
After completion, create `.planning/phases/16-service-hardening/16-00-SUMMARY.md` documenting:
- Test scaffold structure and purpose
- Nyquist principle application (tests before code)
- Todo markers for each module's test cases
- Integration with Plans 16-01 and 16-02
</output>
